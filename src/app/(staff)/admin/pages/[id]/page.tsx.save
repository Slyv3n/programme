'use client';

import { useState, useEffect, useMemo } from 'react';
import { Block, Page } from "@prisma/client";
import useSWR from 'swr';
import { useParams, useSearchParams } from "next/navigation";
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { DndContext, DragEndEvent, DragOverlay } from '@dnd-kit/core';
import { SortableContext, arrayMove, verticalListSortingStrategy } from '@dnd-kit/sortable';

import { PageSettingsForm } from '@/components/admin/PageSettingsForm';
import { HeroBlockForm } from '@/components/admin/block-forms/HeroBlockForm';
import { BlockItem } from '@/components/admin/BlockItem';
import { CtaButtonBlockForm } from '@/components/admin/block-forms/CtaButtonBlockForm';
import { LanguageSwitcherBlockForm } from '@/components/admin/block-forms/LanguageSwitcherBlockForm';
import { toast } from 'sonner';

const fetcher = (url: string) => fetch(url).then(res => res.json());

type PageWithBlocks = Page & { blocks: Block[] };

const blockForms: { [key: string]: React.FC<any> } = {
  hero: HeroBlockForm,
  ctaButton: CtaButtonBlockForm,
  languageSwitcher: LanguageSwitcherBlockForm,
};

export default function VisualPageBuilder() {
  const params = useParams();
  const searchParams = useSearchParams();
  const id = params.id as string;
  const { data: pageData, error, mutate } = useSWR<PageWithBlocks>(`/api/pages/${id}`, fetcher);

  const [containers, setContainers] = useState<{ [key: string]: number[] }>({ root: [] });
  const [selectedBlock, setSelectedBlock] = useState<Block | null>(null);
  const [iframeKey, setIframeKey] = useState(Date.now());
  const [activeDragId, setActiveDragId] = useState<number | null>(null);

  const allBlocks = useMemo(() => pageData?.blocks || [], [pageData]);
  const rootBlocks = useMemo(() => allBlocks.filter(b => b.parentId === null).sort((a,b) => a.order - b.order), [allBlocks]);
  
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      if (event.source !== document.getElementById('preview-iframe')?.contentWindow) return;
      const { type, blockId } = event.data;
      if (type === 'EDIT_BLOCK' && allBlocks) {
        const blockToEdit = allBlocks.find(b => b.id === blockId);
        if (blockToEdit) setSelectedBlock(blockToEdit);
      }
    };
    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, [allBlocks]);

  const handleDragEnd = async (event: DragEndEvent) => {
    setActiveDragId(null);
    const { active, over } = event;
    if (over && active.id !== over.id) {
        const reorderedBlocks = arrayMove(allBlocks, allBlocks.findIndex(b => b.id === active.id), allBlocks.findIndex(b => b.id === over.id));
        
        mutate({ ...pageData, blocks: reorderedBlocks } as PageWithBlocks, false);

        const blocksToUpdate = reorderedBlocks.map((block, index) => ({ id: block.id, order: index }));

        await fetch('/api/blocks/reorder', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ orderedBlocks: blocksToUpdate }),
        });
        
        mutate();
        setIframeKey(Date.now());
    }
  };

  const handleAddBlock = async (parentId: number | null, column: string | null) => {
    try {
      let order = 0;
      if (parentId === null) {
        order = containers.root.length;
      } else {
        order = (containers[`${parentId}-${column}`] || []).length;
      }
      
      const response = await fetch('/api/blocks', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: 'text',
          pageId: parseInt(id),
          order,
          parentId,
          column
        }),
      });
      if (!response.ok) throw new Error("La création du bloc a échoué.");

      toast(`Bloc Texte ajouté.`);
      mutate();
      setIframeKey(Date.now());
    } catch (err) {
      toast("Une erreur est survenue.");
    }
  };
  
  const handleDeleteBlock = async (blockId: number) => {
    try {
      await fetch(`/api/blocks/${blockId}`, { method: 'DELETE' });
      toast("Bloc supprimé.");
      mutate();
      setIframeKey(Date.now());
    } catch (error) {
      console.log(error);
      toast("Une erreur est survenue.");
    }
  };

  if (error) return <div className="p-10 text-center text-red-500">Erreur de chargement.</div>;
  if (!pageData) return <div className="p-10 text-center">Chargement...</div>;

  const FormComponent = selectedBlock ? blockForms[selectedBlock.type] : null;
  const adminKioskId = searchParams.get('kioskId');
  const previewKioskId = adminKioskId || 'ADMIN_PREVIEW';
  const iframeSrc = `/p/${pageData.id}?edit_mode=true&kioskId=${previewKioskId}`;
  const activeBlock = activeDragId ? allBlocks.find(b => b.id === activeDragId) : null;

  return (
    <DndContext onDragStart={e => setActiveDragId(e.active.id as number)} onDragEnd={handleDragEnd}>
      <div className="flex h-[calc(100vh-65px)] bg-gray-100">
        <aside className="w-96 bg-white p-4 flex flex-col border-r overflow-y-auto">
          <div className="flex-grow">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-bold truncate pr-2">Éditeur : {pageData.name}</h2>
              <Button asChild variant="outline" size="sm"><Link href="/admin/pages">← Retour</Link></Button>
            </div>
            <div className="border-b pb-4 mb-4">
              <h3 className="font-semibold mb-2">Paramètres de la Page</h3>
              <PageSettingsForm page={pageData} onSave={() => { mutate(); setIframeKey(Date.now()); }} />
            </div>
            <h3 className="font-semibold mb-2">Blocs Racine</h3>
            <SortableContext items={rootBlocks.map(b => b.id)} strategy={verticalListSortingStrategy}>
                <div className="space-y-2">
                {rootBlocks.map((block) => (
                    <BlockItem 
                        key={block.id} 
                        block={block} 
                        allBlocks={allBlocks}
                        onEdit={setSelectedBlock}
                        onDelete={handleDeleteBlock}
                        onAddBlock={handleAddBlock}
                    />
                ))}
                </div>
            </SortableContext>
          </div>
          <div className="mt-6 border-t pt-4">
            <h3 className="text-lg font-semibold mb-2">Ajouter un bloc à la page</h3>
            <div className="flex gap-2 flex-wrap">
              <Button size="sm" variant="secondary" onClick={() => handleAddBlock('hero', null, null)}>Hero</Button>
              <Button size="sm" variant="secondary" onClick={() => handleAddBlock('text', null, null)}>Texte</Button>
              <Button size="sm" variant="secondary" onClick={() => handleAddBlock('productGrid', null, null)}>Grille Produits</Button>
              <Button size="sm" variant="secondary" onClick={() => handleAddBlock('columnLayout', null, null)}>Mise en page (Colonnes)</Button>
            </div>
          </div>
        </aside>

        <main className="flex-grow">
          <iframe id="preview-iframe" key={iframeKey} src={iframeSrc} className="w-full h-full border-none bg-white" />
        </main>
      </div>

      <DragOverlay>
        {activeBlock ? <BlockItem block={activeBlock} isDragging allBlocks={[]} onEdit={() => {}} onDelete={() => {}} onAddBlock={() => {}}/> : null}
      </DragOverlay>

      <Dialog open={!!selectedBlock} onOpenChange={() => setSelectedBlock(null)}>
        <DialogContent className="bg-white">
          <DialogHeader><DialogTitle>Modifier le bloc : {selectedBlock?.type}</DialogTitle></DialogHeader>
          {FormComponent && <FormComponent block={selectedBlock} onSave={() => { setSelectedBlock(null); mutate(); setIframeKey(Date.now()); }} />}
        </DialogContent>
      </Dialog>
    </DndContext>
  );
}